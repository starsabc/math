# 实验课4 方差分析 & 数据整理

setwd('F://tongji/l4')



#----------- 多个均数比较-方差分析------------

data1 <- read.csv('data1.csv')
data2 <- read.csv('data2.csv')
library(tidyverse)

# 完全随机设计的方差分析 one-way ANOVA, 连续变量（正态分布） & 分类变量（多分类）
# BMI < 18.5	underweight; 18.5 <= BMI ＜24	 normal;
# 24 <= BMI < 28	overweight; BMI ＞= 28	obesity.å
data1$BMI_group <- case_when(data1$BMI < 18.5 ~ 'underweight',
                             data1$BMI >= 18.5 & data1$BMI<24 ~ 'normal',
                             data1$BMI >= 24 & data1$BMI < 28 ~ 'overweight',
                             data1$BMI >= 28 ~ 'obesity')
summary(as.factor(data1$BMI_group))

# 不同体重组的年龄分布
data1 %>% 
  group_by(BMI_group) %>%
  summarise(
    count = n(),
    mean = mean(Age, na.rm = TRUE),
    sd = sd(Age, na.rm = TRUE)
  )


# 画图
ggplot(data1, aes(x=BMI_group, y=Age, fill=BMI_group)) + 
  geom_boxplot()

# 方差分析
fit <- aov(data1$Age ~ data1$BMI_group) 
model.tables(fit,"means") # 样本均值；每组均值和频数
summary(fit) #F统计量和p值

fit_rbd <- aov(data1$BPSysAve ~ data1$BMI_group + data1$Gender)
summary(fit_rbd)



############################## 列操作 ###################################

# library(readr)
df <- read_csv('data_score.csv')
df 

# 1. 新增列 mutate & tranmute
reward <- c(2, 5, 9, 8, 5, 6)
mutate(.data = df, extra = reward) 

df %>% mutate(extra = reward) 

df_new <- df %>% 
  mutate(extra = reward) %>% 
  mutate(total = score + extra)
df_new

df_new %>% 
  transmute(total = score + extra)

df_new %>% 
  transmute(total = score + extra, 
            diff = score - extra)

df_new %>% 
  mutate(grade = case_when(
    total > 90 ~ "A",
    total > 80 ~ "B",
    total > 70 ~ "C",
    TRUE ~ "D"
  ))


# 2. select & pull 对列进行选择
df_new %>% select(name)
df_new %>% pull(name)

df_new %>% select(name, extra)
df_new %>% select(name, score, extra, total)

df_new %>% select(1, 2, 3)
df_new %>% select(2:3)


## 如果不想要某列，可以在变量前面加 - 或者 !，两者的结果是一样的。
df_new %>% select(-type)
df_new %>% select(!type)

df_new %>% select(where(is.character))
df_new %>% select(where(is.numeric))


# 3. rename重命名列名
df_new %>% 
  rename(total_score = total)

df_new %>% 
  select(name, type, total) %>% 
  rename(total_score = total)


# 4. relocate重新排列列名
df_new %>% relocate(score)
df_new %>% relocate(score,.after=extra)
df_new %>% relocate(type,.before=name)
df_new %>% relocate(type, score, .before=name)



############################## 行操作 ###################################

# 1. 排序arrange
df_new %>% arrange(total)
df_new %>% arrange(-total)  # 降序排列
df_new %>% arrange(desc(total))  # 降序排列

df_new %>% 
  arrange(type, desc(total))  # 对多个变量依次排序


# 2. 筛选行 filter & slice
df_new %>% filter(score == 90)
df_new %>% filter(score >= 80)
df_new %>% filter(score %in% c(70, 90))

df_new %>% filter(type == "english", score >= 75)
df_new %>% filter(type == "english" & score >= 75)
df_new %>% filter(score == 70 | score == 90)

df_new %>% filter(score == max(score))
df_new %>% filter(score > mean(score))

df_new %>% slice(2:3)
df_new %>% slice_head(n=3)
df_new %>% slice_tail(n=3)
df_new %>% slice_min(score, n=1)
df_new %>% slice_max(score, n=2)


# 3. 去除重复值
df %>% distinct() 

df_dup <- add_row(df, name = 'Alice', type = 'math', score=60)
df_dup
df_dup %>% distinct() 
df_dup %>% distinct(name, type) 



##############################  缺失值 ###################################

library(tidyverse)
install.packages('palmerpenguins')
library(palmerpenguins)

penguins

## 1. 统计有多少缺失值 
sum_of_na <- function(x){
  sum(is.na(x))
}

c(1, 2, NA, 4) %>% sum_of_na()
penguins$bill_length_mm %>% sum_of_na()

penguins %>% summarise(
  N1 = sum_of_na(bill_length_mm),
  N2 = sum_of_na(bill_depth_mm),
  N3 = sum_of_na(sex)
)

# library(purrr)
penguins %>% map(~ sum(is.na(.)))
penguins %>% map_df(~ sum(is.na(.)))
penguins %>%
  summarise_at(2:3, ~ sum(is.na(.)))


## 2. 删除缺失值
penguins %>% drop_na()

penguins %>%
  drop_na(sex)

å
## 3. 填补缺失值

### 用附近数据填充
penguins %>% fill(bill_length_mm)   # 利用上一行数据填充
penguins %>% fill(bill_length_mm, bill_depth_mm)
penguins %>% fill(bill_length_mm, .direction = "up")  # 利用下一行数据填充

### 用特定值替换
penguins %>% mutate(bill_length_mm_fill = replace_na(bill_length_mm, 0)) 
penguins %>% mutate(bill_length_mm = coalesce(bill_length_mm, 0))

### 用均值替换
penguins %>%
  mutate(
    bill_length_mm = replace_na(bill_length_mm, mean(bill_length_mm, na.rm = TRUE))
  )




############################## 数据合并 ###################################

# 1. left_join & right_join
df1 <- df_new %>% 
  group_by(name) %>% 
  summarise( 
    mean_score = mean(total) 
  )
df1

df2 <- tibble(
  name = c("Alice", "Bob", "Dave"),
  age =  c(12, 13, 14)
)
df2

left_join(df1, df2, by = "name")
df1 %>% left_join(df2, by = "name") #  使用%>%
df1 %>% right_join(df2, by = "name")

# Carol同学的信息没有显示？ Dave 同学显示了但没有考试成绩？大家想想又为什么呢？
# left_join()是左联结，即以左边数据框df1中的学生姓名name为准，在右边数据框df2里，有Alice和Bob的年龄，那么就对应联结过来，没有Carol的年龄，自然就为缺失值NA。
# right_join()是右联结，要以右边数据框df2中的学生姓名name为准，即Alice，Bob和Dave，而df1只有Alice和Bob的信息，没有Dave的信息，因此Dave对应的成绩为NA。


# 2. full_join & inner_join
df1 %>% full_join(df2, by = "name")
df1 %>% inner_join(df2, by = "name")


# 3. semi_join & anti_join
# 筛选联结，有两个semi_join(x, y)和anti_join(x, y)，
# 函数不改变数据框x的变量的数量，主要影响的是x的观测，
# 也就说会剔除一些行，其功能类似filter()

# 半联结semi_join(x, y)，保留name与df2的name相一致的所有行
df1 %>% semi_join(df2, by = "name")
df1 %>% filter(
  name %in% df2$name
)

# 反联结anti_join(x, y)，丢弃name与df2的name相一致的所有行
df1 %>% anti_join(df2, by = "name")
df1 %>% filter(
  ! name %in% df2$name
)



############################# 元素合并 ##################################

df_new1 <- df_new %>% 
  unite(name, type, col='name_type', sep='/')
df_new1

df_new1 %>% separate(name_type, sep='/', into=c('name', 'type'))

df_new1 <- df_new %>% 
  unite(name, score, col='name_score', sep='/')
df_new1

df_new1 %>% separate(name_score, sep='/', into=c('name1', 'score1'))
df_new1 %>% separate(name_score, sep='/', into=c('name1', 'score1'), convert=T)



############################# 长宽表格 ##################################

# 1. 转长数据 pivot_longer()

# 这里pivot_longer()函数有三个主要的参数：
# 参数cols，表示哪些列需要转换.
# 参数names_to，表示cols选取的这些列的名字，构成了新的一列，这里需要取一个名字.
# 参数values_to， 表示cols选取的这些列的值，构成了新的一列，这里也需要取一个名字.
# 数据框总的信息量不会丢失

long <- df_new %>%
  pivot_longer(
    cols = score:total,
    names_to = "score_part",
    values_to = "value"
  )
long


df_new %>%
  pivot_longer(
    cols = c(-type, -name),
    names_to = "score_part",
    values_to = "value"
  )


# 2. 转宽数据 pivot_wider()

long %>% 
  pivot_wider(
    names_from = "score_part",
    values_from = "value"
  )



############################## 统计汇总 ###################################

# 1. summarise 统计汇总

df_new %>% summarise(mean_score = mean(score))
df_new %>% summarise( sd_score = sd(score))
df_new %>% summarise(
  mean_score   = mean(score),
  median_score = median(score),
  n            = n(),
  sum          = sum(score),
  iqr          = IQR(score)
)

# summarise中常用的汇总函数有：
# 
# 位置度量：mean(), median()。
# 分散程度（变异性）度量：sd(), IQR(), mad()。
# 分位数：min(), max(), quantile()。
# 按下标查询，如first(x)取出x[1]， last(x)取出x的最后一个元素， nth(x,2)取出x[2]。 可以提供一个缺省值以防某个下标位置不存在。
# 计数：n()给出某个组的观测数， sum(!is.na(x))统计x的非缺失值个数， n_distinct(x)统计x的不同值个数(缺失值也算一个值)， 也可以计算多个变量的不同组合值个数。
# count(x)给出x的每个不同值的个数（类似于table()函数）， 但count(x)只能单独作为管道运算的一个步骤， 不能用在summarise函数中。


# 2. 分组group_by
df_new %>%
  group_by(name)

df_new %>%
  group_by(name) %>%
  summarise(
    mean_score = mean(total),
    sd_score   = sd(total)
  )


# 3. summarize + across
df_new %>%
  summarize(
    score = mean(score),
    extra  = mean(extra)
  )

df_new %>%
  summarize(
    across(c(score, extra), mean)
  )

df_new %>%
  summarize(
    across(c(score, extra), c(mean, sd))
  )

# across(.cols = everything(), .fns = NULL, ..., .names = NULL)


# 4. 中心化
centralized <- function(x) {
  x - mean(x)
}

df_new %>%
  mutate(
    across(c(score, extra, total), centralized)
  )


# 5. 标准化
std <- function(x) {
  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
}

df_new %>%
  mutate(
    across(c(score, extra, total), std)
  )


# 6. 再看重复值
df_new %>% group_by(name) %>% slice(1) %>% data.frame()
df_new %>% group_by(name) %>% slice(2) %>% data.frame()
df_new %>% group_by(name) %>% slice(n()) %>% data.frame()
df_new %>% group_by(name) %>% slice_sample(n = 1) %>% data.frame()
df_new %>% group_by(name) %>% arrange(desc(extra)) %>% slice(1) %>% data.frame()


